# -*- coding: utf-8 -*-
import re

from lxml import etree
from edxml.EDXMLBase import EDXMLValidationError
from edxml.ontology import OntologyElement


class Concept(OntologyElement):
    """
    Class representing an EDXML concept
    """

    NAME_PATTERN = re.compile('^[a-z0-9.]{1,64}$')
    DISPLAY_NAME_PATTERN = re.compile("^[ a-zA-Z0-9]*/[ a-zA-Z0-9]*$")

    def __init__(self, ontology, name, display_name=None, description=None):

        self._attr = {
            'name': name,
            'display-name': display_name or ' '.join(('%s/%s' % (name, name)).split('.')),
            'description': description or name,
            'version': 1
        }

        self._ontology = ontology  # type: edxml.ontology.Ontology

    def _child_modified_callback(self):
        """Callback for change tracking"""
        self._ontology._child_modified_callback()
        return self

    def _set_attr(self, key, value):
        if self._attr[key] != value:
            self._attr[key] = value
            self._child_modified_callback()

    def get_name(self):
        """

        Returns the name of the concept.

        Returns:
          str: The concept name
        """

        return self._attr['name']

    def get_display_name(self):
        """

        Returns the display-name attribute of the concept.

        Returns:
          str:
        """

        return self._attr['display-name']

    def get_display_name_singular(self):
        """

        Returns the display name of the concept, in singular form.

        Returns:
          str:
        """

        return self._attr['display-name'].split('/')[0]

    def get_display_name_plural(self):
        """

        Returns the display name of the concept, in plural form.

        Returns:
          str:
        """

        return self._attr['display-name'].split('/')[1]

    def get_description(self):
        """

        Returns the description of the concept.

        Returns:
          str:
        """

        return self._attr['description']

    def get_version(self):
        """

        Returns the version of the concept definition.

        Returns:
          int:
        """

        return self._attr['version']

    def set_description(self, description):
        """

        Sets the concept description

        Args:
          description (str): Description

        Returns:
          edxml.ontology.Concept: The Concept instance
        """

        self._set_attr('description', str(description))
        return self

    def set_display_name(self, singular, plural=None):
        """

        Configure the display name. If the plural form
        is omitted, it will be auto-generated by
        appending an 's' to the singular form.

        Args:
          singular (str): display name (singular form)
          plural (str): display name (plural form)

        Returns:
          edxml.ontology.Concept: The Concept instance
        """

        if plural is None:
            plural = '%ss' % singular

        self._set_attr('display-name', '%s/%s' % (singular, plural))
        return self

    def set_version(self, version):
        """

        Sets the concept version

        Args:
          version (int): Version

        Returns:
          edxml.ontology.Concept: The Concept instance
        """

        self._set_attr('version', int(version))
        return self

    def validate(self):
        """

        Checks if the concept is valid. It only looks
        at the attributes of the definition itself. Since it does
        not have access to the full ontology, the context of
        the ontology is not considered. For example, it does not
        check if other, conflicting concept definitions exist.

        Raises:
          EDXMLValidationError

        Returns:
          edxml.ontology.Concept: The Concept instance

        """
        if not len(self._attr['name']) <= 64:
            raise EDXMLValidationError(
                'The name of concept "%s" is too long.' % self._attr['name'])
        if not re.match(self.NAME_PATTERN, self._attr['name']):
            raise EDXMLValidationError(
                'Concept "%s" has an invalid name.' % self._attr['name'])

        if not len(self._attr['display-name']) <= 64:
            raise EDXMLValidationError(
                'The display name of concept "%s" is too long: "%s".' % (
                    self._attr['name'], self._attr['display-name'])
            )
        if not re.match(self.DISPLAY_NAME_PATTERN, self._attr['display-name']):
            raise EDXMLValidationError(
                'Concept "%s" has an invalid display name: "%s"' % (
                    self._attr['name'], self._attr['display-name'])
            )

        if not len(self._attr['description']) <= 128:
            raise EDXMLValidationError(
                'The description of concept "%s" is too long: "%s"' % (
                    self._attr['name'], self._attr['description'])
            )

        return self

    @classmethod
    def create_from_xml(cls, type_element, ontology):
        return cls(
            ontology,
            type_element.attrib['name'],
            type_element.attrib['display-name'],
            type_element.attrib['description'],
        ).set_version(type_element.attrib['version'])

    def __cmp__(self, other):

        if not isinstance(other, type(self)):
            raise TypeError("Cannot compare different types of ontology elements.")

        other_is_newer = other.get_version() > self.get_version()
        versions_differ = other.get_version() != self.get_version()

        if other_is_newer:
            new = other
            old = self
        else:
            new = self
            old = other

        old.validate()
        new.validate()

        equal = not versions_differ

        if old.get_name() != new.get_name():
            raise ValueError("Concepts with different names are not comparable.")

        # Compare attributes that cannot produce illegal upgrades because they can
        # be changed freely between versions. We only need to know if they changed.

        equal &= old.get_display_name_singular() == new.get_display_name_singular()
        equal &= old.get_display_name_plural() == new.get_display_name_plural()
        equal &= old.get_description() == new.get_description()

        if equal:
            return 0

        if versions_differ:
            return -1 if other_is_newer else 1

        raise EDXMLValidationError(
            "Concept definitions are neither equal nor valid upgrades / downgrades of one another "
            "due to the following difference in their definitions:\nOld version:\n{}\nNew version:\n{}".format(
                etree.tostring(old.generate_xml(), pretty_print=True),
                etree.tostring(new.generate_xml(), pretty_print=True)
            )
        )

    def update(self, concept):
        """
        Update the concept using information from the provided
        concept and validate the result.

        Args:
          concept (edxml.ontology.Concept): The new Concept instance

        Returns:
          edxml.ontology.Concept: The updated Concept instance

        """
        if concept > self:
            # The new definition is indeed newer. Update self.
            self.set_display_name(concept.get_display_name_singular(), concept.get_display_name_plural())
            self.set_description(concept.get_description())
            self.set_version(concept.get_version())

        return self

    def generate_xml(self):
        """

        Generates an lxml etree Element representing
        the EDXML <concept> tag for this concept.

        Returns:
          etree.Element: The element

        """
        attribs = dict(self._attr)
        attribs['version'] = unicode(attribs['version'])

        return etree.Element('concept', attribs)
