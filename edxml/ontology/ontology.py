# -*- coding: utf-8 -*-
import uuid

from lxml import etree

from typing import Dict

import edxml.ontology
from edxml.EDXMLBase import EDXMLValidationError
from edxml.ontology import *


class Ontology(object):
  """
  Class representing an EDXML ontology
  """

  def __init__(self):
    self._event_types = {}    # type: Dict[str, edxml.ontology.EventType]
    self._object_types = {}   # type: Dict[str, edxml.ontology.ObjectType]
    self._sources = {}        # type: Dict[str, edxml.ontology.EventSource]

  def CreateObjectType(self, Name, DisplayNameSingular = None, DisplayNamePlural = None,
                       Description = None, DataType ='string:0:cs:u'):
    """

    Creates and returns a new ObjectType instance. When no display
    names are specified, display names will be created from the
    object type name. If only a singular form is specified, the
    plural form will be auto-generated by appending an 's'.

    Args:
      Name (str): object type name
      DisplayNameSingular (str): display name (singular form)
      DisplayNamePlural (str): display name (plural form)
      Description (str): short description of the object type
      DataType (str): a valid EDXML data type

    Returns:
      ObjectType: The ObjectType instance
    """

    if DisplayNameSingular:
      DisplayName = '%s/%s' % (DisplayNameSingular, DisplayNamePlural if DisplayNamePlural else '%ss' % DisplayNameSingular)
    else:
      DisplayName = '/'

    if Name not in self._object_types:
      self._object_types[Name] = ObjectType(self, Name, DisplayName, Description, DataType)
    else:
      raise NameError('Attempt to create existing object type: "%s"' % Name)

    self._childModifiedCallback()
    return self._object_types[Name]

  def CreateEventType(self, Name, DisplayNameSingular=None, DisplayNamePlural=None, Description=None):
    """

    Creates and returns a new EventType instance. When no display
    names are specified, display names will be created from the
    event type name. If only a singular form is specified, the
    plural form will be auto-generated by appending an 's'.

    Args:
      Name (str): Event type name
      DisplayNameSingular (str): Display name (singular form)
      DisplayNamePlural (str): Display name (plural form)
      Description (str): Event type description

    Returns:
      EventType: The EventType instance
    """
    if DisplayNameSingular:
      DisplayName = '%s/%s' % (DisplayNameSingular, DisplayNamePlural if DisplayNamePlural else '%ss' % DisplayNameSingular)
    else:
      DisplayName = None

    if Name not in self._event_types:
      self._event_types[Name] = EventType(self, Name, DisplayName, Description)
    else:
      raise NameError('Attempt to create existing event type: "%s"' % Name)

    self._childModifiedCallback()
    return self._event_types[Name]

  def CreateEventSource(self, Url, Description=None, AcquisitionDate=None):
    """

    Creates a new event source definition. If no acquisition date
    is specified, it will be assumed that the acquisition date
    is today.

    Note:
      Choose your source URLs wisely. The source URLs are used in
      sticky hash computations, so changing the URL may have quite
      a few consequences if the hash is referred to anywhere. Also,
      pay attention to the URL in the context of URLs generated by
      other EDXML data sources, to obtain a consistent, well structured
      source URL tree.

    Args:
     Url (str): The source URL
     Description (str): Description of the source
     AcquisitionDate (str): Acquisition date in format yyyymmdd

    Returns:
      EventSource:
    """

    if Url not in self._sources:
      self._sources[Url] = EventSource(self, uuid.uuid4(), Url, Description, AcquisitionDate)
    else:
      raise NameError('Attempt to create existing event source: "%s"' % Url)

    self._childModifiedCallback()
    return self._sources[Url]

  def _addEventType(self, eventType):
    """

    Adds specified event type to the ontology. If the
    event type exists in the ontology, it will be checked
    for consistency with the existing definition.

    Args:
      eventType (EventType): An EventType instance
    Returns:
      Ontology: The ontology
    """
    name = eventType.GetName()

    if name in self._event_types:
      self._event_types[name].Update(eventType)
    else:
      self._event_types[name] = eventType.Validate()._setOntology(self)

    self._invalidate()
    return self

  def _addObjectType(self, objectType):
    """

    Adds specified object type to the ontology. If the
    object type exists in the ontology, it will be checked
    for consistency with the existing definition.

    Args:
      objectType (ObjectType): An ObjectType instance
    Returns:
      Ontology: The ontology
    """
    name = objectType.GetName()

    if name in self._object_types:
      self._object_types[name].Update(objectType)
    else:
      self._object_types[name] = objectType.Validate()._setOntology(self)

    self._invalidate()
    return self

  def _addEventSource(self, eventSource):
    """

    Adds specified event source to the ontology. If the
    event source exists in the ontology, it will be checked
    for consistency with the existing definition.

    Args:
      eventSource (EventSource): An EventSource instance
    Returns:
      Ontology: The ontology
    """
    url = eventSource.GetUrl()

    if url in self._sources:
      self._sources[url].Update(eventSource)
    else:
      self._sources[url] = eventSource.Validate()._setOntology(self)

    return self

  def GenerateEventTypes(self):
    """

    Generates all event types in the ontology as
    dictionary elements. The keys are the event type
    names, the values are EventType instances.

    Yields:
      EventType: EventType instance
    """
    for name, eventType in self._event_types.items():
      yield name, eventType

  def GenerateObjectTypes(self):
    """

    Generates all object types in the ontology as
    dictionary elements. The keys are the object type
    names, the values are ObjectType instances.

    Yields:
      ObjectType: ObjectType instance
    """
    for name, objectType in self._object_types.items():
      yield name, objectType

  def GenerateEventSources(self):
    """

    Generates all event sources in the ontology as
    dictionary elements. The keys are the event source
    URLs, the values are EventSource instances.

    Yields:
      EventSource: EventSource instance
    """
    for url, eventSource in self._sources.items():
      yield url, eventSource

  def GetEventTypeNames(self):
    """

    Returns the list of names of all defined
    event types.

    Returns:
       List[str]: List of event type names
    """
    return self._event_types.keys()

  def GetObjectTypeNames(self):
    """

    Returns the list of names of all defined
    object types.

    Returns:
       List[str]: List of object type names
    """
    return self._object_types.keys()

  def GetEventType(self, Name):
    """

    Returns the EventType instance having
    specified event type name, or None if
    no event type with that name exists.

    Args:
      Name (str): Event type name
    Returns:
      EventType: The event type instance
    """
    return self._event_types.get(Name)

  def GetObjectType(self, Name):
    """

    Returns the ObjectType instance having
    specified object type name, or None if
    no object type with that name exists.

    Args:
      Name (str): Object type name
    Returns:
      ObjectType: The object type instance
    """
    return self._object_types.get(Name)

  def GetEventSource(self, Url):
    """

    Returns the EventSource instance having
    specified event source URL, or None if
    no event source with that URL exists.

    Args:
      Url (str): Event source URL
    Returns:
      EventSource: The event source instance
    """
    return self._sources.get(Url)

  def GetEventSourceById(self, Id):
    # TODO: Remove this method as soon as the event-id
    # attribute is gone.
    for sourceUrl, source in self._sources.items():
      if source.GetId() == Id:
        return source

  def __parseEventTypes(self, eventtypesElement):
    for typeElement in eventtypesElement:
      self._addEventType(EventType.Read(typeElement, self))

  def __parseObjectTypes(self, objecttypesElement):
    for typeElement in objecttypesElement:
      self._addObjectType(
        ObjectType.Read(typeElement, self)
      )

  def __parseSources(self, sourcesElement):
    for sourceElement in sourcesElement:
      self._addEventSource(EventSource.Read(sourceElement, self))

  def Validate(self):
    """

    Checks if the defined ontology is a valid EDXML ontology.

    Raises:
      EDXMLValidationError
    Returns:
      Ontology: The ontology

    """
    # Validate all object types
    for objectTypeName, objectType in self._object_types.items():
      objectType.Validate()

    # Validate all event types and their
    # reporter strings
    for eventTypeName, eventType in self._event_types.items():
      eventType.Validate()
      eventType.ValidateReporterString(eventType.GetReporterShort(), self)
      eventType.ValidateReporterString(eventType.GetReporterLong(), self)

    # Check if all event type parents are defined
    for eventTypeName, eventType in self._event_types.items():
      eventType.Validate()
      if eventType.GetParent() is not None:
        if eventType.GetParent().GetEventType() not in self._event_types:
          raise EDXMLValidationError('Event type "%s" refers to parent event type "%s", which is not defined.' %
                                     (eventTypeName, eventType.GetParent().GetEventType()))

    # Check if the object type of each property exists
    for eventTypeName, eventType in self._event_types.iteritems():
      for propertyName, eventProperty in eventType.iteritems():
        if self.GetObjectType(eventProperty.GetObjectTypeName()) is None:
          raise EDXMLValidationError(
            'Property "%s" of event type "%s" refers to undefined object type "%s".' %
            (propertyName, eventTypeName, eventProperty.GetObjectTypeName())
          )

    # Check if merge strategies make sense for the
    # configured property merge strategies
    for eventTypeName, eventType in self._event_types.iteritems():
      for propertyName, eventProperty in eventType.iteritems():
        if eventProperty.GetMergeStrategy() in ('min', 'max', 'increment', 'sum', 'multiply'):
          if not eventProperty.GetDataType().IsNumerical():
            raise EDXMLValidationError(
              ('Property "%s" of event type "%s" with merge strategy min, max, increment, sum or multiply '
               'must be a number or timestamp.') % (propertyName, eventTypeName)
            )

    # Check if unique properties have their merge strategies set
    # to 'match'
    # TODO: Still needed for EDXML 3?
    for eventTypeName, eventType in self._event_types.iteritems():
      for propertyName, eventProperty in eventType.iteritems():
        if eventProperty.IsUnique():
          if eventProperty.GetMergeStrategy() != 'match':
            raise EDXMLValidationError(
              'Unique property "%s" of event type "%s" does not have its merge strategy set to "match".' %
              (propertyName, eventTypeName)
            )
        else:
          if eventProperty.GetMergeStrategy() == 'match':
            raise EDXMLValidationError(
              'Property "%s" of event type "%s" is not unique but it does have its merge strategy set to "match".' %
              (propertyName, eventTypeName)
            )

    # Verify that non-unique event type only have
    # properties with merge strategy 'drop'.
    for eventTypeName, eventType in self._event_types.iteritems():
      if not eventType.IsUnique():
        for propertyName, eventProperty in eventType.iteritems():
          if eventProperty.GetMergeStrategy() != 'drop':
            raise EDXMLValidationError(
              'Event type "%s" is not unique, but property "%s" has merge strategy %s.' %
              (eventTypeName, propertyName, eventProperty.GetMergeStrategy())
            )

    # Validate event parent definitions
    for eventTypeName, eventType in self._event_types.items():
      if eventType.GetParent() is None:
        continue

      # Check if all unique parent properties are present
      # in the property map
      parentEventType = self.GetEventType(eventType.GetParent().GetEventType())
      for parentPropertyName, parentProperty in parentEventType.iteritems():
        if parentProperty.IsUnique():
          if parentPropertyName not in eventType.GetParent().GetPropertyMap().values():
            raise EDXMLValidationError(
              'Event type %s contains a parent definition which lacks a mapping for unique parent property \'%s\'.' %
              (eventTypeName, parentPropertyName)
            )

      for childProperty, parentProperty in eventType.GetParent().GetPropertyMap().items():

        # Check if child property exists
        if childProperty not in eventType.keys():
          raise EDXMLValidationError(
            'Event type %s contains a parent definition which refers to unknown child property \'%s\'.' %
            (eventTypeName, childProperty)
          )

        # Check if parent property exists and if it is a unique property
        parentEventType = self.GetEventType(eventType.GetParent().GetEventType())
        if parentProperty not in parentEventType.keys() or \
           parentEventType[parentProperty].GetMergeStrategy() != 'match':
          raise EDXMLValidationError(
            ('Event type %s contains a parent definition which refers to parent property "%s" of event type %s, '
             'but this property is not unique, or it does not exist.') %
            (eventTypeName, parentProperty, eventType.GetParent().GetEventType())
          )

        # Check if child property has allowed merge strategy
        if eventType[childProperty].GetMergeStrategy() not in ('match', 'drop'):
          raise EDXMLValidationError(
            ('Event type %s contains a parent definition which refers to child property \'%s\'. '
             'This property has merge strategy %s, which is not allowed for properties that are used in '
             'parent definitions.') %
            (eventTypeName, childProperty, eventType[childProperty].GetMergeStrategy())
          )

    return self

  @classmethod
  def Read(cls, definitionsElement):
    """

    Args:
      definitionsElement (lxml.etree.Element):

    Returns:
      Ontology: The ontology
    """

    ontology = cls()

    for element in definitionsElement:
      if element.tag == 'eventtypes':
        ontology.__parseEventTypes(element)
      elif element.tag == 'objecttypes':
        ontology.__parseObjectTypes(element)
      elif element.tag == 'sources':
        ontology.__parseSources(element)
      else:
        raise TypeError('Unexpected element: "%s"' % element.tag)

    return ontology

  def Update(self, otherOntology):
    """

    Updates the ontology using the definitions contained
    in another ontology. The other ontology may be specified
    in the form of an Ontology instance or an lxml Element
    containing a full definitions element.

    Args:
      otherOntology (Union[lxml.etree.Element,Ontology]):

    Returns:
      Ontology: The ontology
    """

    if type(otherOntology) == Ontology:
      for ObjectTypeName, objectType in otherOntology.GenerateObjectTypes():
        self._addObjectType(objectType)
      for EventTypeName, eventType in otherOntology.GenerateEventTypes():
        self._addEventType(eventType)
      for Url, source in otherOntology.GenerateEventSources():
        self._addEventSource(source)

    elif isinstance(otherOntology, etree._Element):
      for element in otherOntology:
        if element.tag == 'eventtypes':
          eventTypes = element
          #self.__parseEventTypes(element)
        elif element.tag == 'objecttypes':
          objectTypes = element
          #self.__parseObjectTypes(element)
        elif element.tag == 'sources':
          sources = element
          #self.__parseSources(element)
        else:
          raise TypeError('Unexpected element: "%s"' % element.tag)

      # As long as object type definitions come after
      # event type definitions in EDXML data, we need
      # to change processing order to prevent event types
      # from trying to read object type information.
      # TODO: Restore as soon as EDXML structure is changed.
      self.__parseObjectTypes(objectTypes)
      self.__parseEventTypes(eventTypes)
      self.__parseSources(sources)

      self.Validate()
    else:
      raise TypeError('Cannot update ontology from %s', str(type(otherOntology)))

    return self

  def GenerateXml(self):
    """

    Generates an lxml etree Element representing
    the EDXML <definitions> tag for this ontology.

    Returns:
      etree.Element: The element

    """
    ontologyElement = etree.Element('definitions')
    eventTypes = etree.SubElement(ontologyElement, 'eventtypes')

    for eventTypeName, eventType in self._event_types.iteritems():
      eventTypes.append(eventType.GenerateXml())

    objectTypes = etree.SubElement(ontologyElement, 'objecttypes')

    for objectTypeName, objectType in self._object_types.iteritems():
      objectTypes.append(objectType.GenerateXml())

    eventSources = etree.SubElement(ontologyElement, 'sources')

    for sourceUrl, source in self._sources.iteritems():
      eventSources.append(source.GenerateXml())

    return ontologyElement
